<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ADRs — FOMC Agent Lab</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <nav>
    <a class="brand" href="index.html">FOMC Agent Lab</a>
    <a href="index.html">Dashboard</a>
    <a href="pipeline.html">Pipeline</a>
    <a href="charts.html">Charts</a>
    <a href="architecture.html">Architecture</a>
    <a href="design.html">Design</a>
    <a href="alternatives.html">Alternatives</a>
    <a href="diagrams.html">Diagrams</a>
    <a href="about.html">About</a>
    <a href="bls-guide.html">BLS Guide</a>
    <a class="active" href="adr.html">ADRs</a>
  </nav>

  <div class="container">
    <div class="page-header">
      <h1>Architectural Decision Records</h1>
      <p class="subtitle">Key technical decisions made during the design and build of this pipeline, recorded for future reference.</p>
    </div>

    <!-- ADR-001 -->
    <div class="card prose">
      <h2>ADR-001: Use S3 for Static Site Hosting</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-15</td></tr>
      </table>
      <h3>Context</h3>
      <p>The project needs a way to publish pipeline results as a public website. Options include EC2 with Nginx, Amplify, or S3 static website hosting.</p>
      <h3>Decision</h3>
      <p>Use Amazon S3 static website hosting with CDK's <code>BucketDeployment</code> to upload the <code>site/</code> directory on each deploy.</p>
      <h3>Consequences</h3>
      <ul>
        <li>No server to manage — zero operational overhead.</li>
        <li>Cost is effectively zero for low-traffic sites.</li>
        <li>No server-side rendering — all interactivity is client-side JavaScript.</li>
      </ul>
    </div>

    <!-- ADR-002 -->
    <div class="card prose">
      <h2>ADR-002: Plain HTML Over a Static Site Generator</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-15</td></tr>
      </table>
      <h3>Context</h3>
      <p>Static site generators like Hugo or Jekyll add build complexity and toolchain dependencies. This is a workshop project where simplicity and transparency matter more than content-management features.</p>
      <h3>Decision</h3>
      <p>Author all pages as plain HTML and CSS with no build step. Data is loaded at runtime from JSON files generated by the Python analytics pipeline.</p>
      <h3>Consequences</h3>
      <ul>
        <li>No build toolchain required — pages are deployed as-is.</li>
        <li>Navigation must be duplicated across pages (no layout inheritance).</li>
        <li>Students can inspect and understand every line without learning a templating language.</li>
      </ul>
    </div>

    <!-- ADR-003 -->
    <div class="card prose">
      <h2>ADR-003: SQS to Decouple Ingestion from Analytics</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-20</td></tr>
      </table>
      <h3>Context</h3>
      <p>After the data-fetcher Lambda writes raw files to S3, the analytics Lambda needs to run. This could be done synchronously (invoke directly), via S3 event notifications to Lambda, or through an SQS queue.</p>
      <h3>Decision</h3>
      <p>Use S3 event notifications to publish to an SQS queue, which triggers the analytics Lambda. A dead-letter queue captures failed messages.</p>
      <h3>Consequences</h3>
      <ul>
        <li>Ingestion and analytics are fully decoupled — either can fail independently.</li>
        <li>Built-in retry semantics and DLQ for observability.</li>
        <li>Adds an extra AWS resource to manage, but CDK makes this trivial.</li>
      </ul>
    </div>

    <!-- ADR-004 -->
    <div class="card prose">
      <h2>ADR-004: CDK Over CloudFormation or Terraform</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-10</td></tr>
      </table>
      <h3>Context</h3>
      <p>Infrastructure needs to be defined as code. CloudFormation (YAML/JSON), Terraform (HCL), and AWS CDK (Python) are all viable options.</p>
      <h3>Decision</h3>
      <p>Use AWS CDK with Python so that infrastructure code and application code share the same language and can live in the same repository.</p>
      <h3>Consequences</h3>
      <ul>
        <li>One language (Python) for the entire project — lower cognitive overhead.</li>
        <li>CDK constructs provide sensible defaults and higher-level abstractions.</li>
        <li>Requires the CDK CLI and Node.js runtime in addition to Python.</li>
      </ul>
    </div>

    <!-- ADR-005 -->
    <div class="card prose">
      <h2>ADR-005: BLS Flat Files Over API</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-20</td></tr>
      </table>
      <h3>Context</h3>
      <p>BLS provides data through both a REST API and publicly hosted flat files (the LABSTAT database). The API has rate limits and requires registration; flat files are freely available over HTTPS.</p>
      <h3>Decision</h3>
      <p>Ingest directly from BLS LABSTAT flat files, using HTTP <code>Last-Modified</code> headers for change detection to avoid re-downloading unchanged files.</p>
      <h3>Consequences</h3>
      <ul>
        <li>No API key management or rate-limit handling.</li>
        <li>Flat file parsing requires understanding the BLS series ID format.</li>
        <li>Change detection via timestamps is simple and effective for batch ingestion.</li>
      </ul>
    </div>

    <!-- ADR-006 -->
    <div class="card prose">
      <h2>ADR-006: Chart.js for Client-Side Visualization</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-25</td></tr>
      </table>
      <h3>Context</h3>
      <p>The site needs to render time series charts from JSON data. Options include D3.js, Chart.js, and server-side image generation.</p>
      <h3>Decision</h3>
      <p>Use Chart.js loaded from a CDN. A single <code>app.js</code> script renders all charts by reading data attributes from canvas elements.</p>
      <h3>Consequences</h3>
      <ul>
        <li>Simple, declarative API — charts are configured with a few lines of JavaScript.</li>
        <li>Interactive tooltips and responsive sizing out of the box.</li>
        <li>Less customizable than D3, but sufficient for this project's needs.</li>
      </ul>
    </div>

  </div>
</body>
</html>
