<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ADRs — FOMC Agent Lab</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23020A20' width='100' height='100' rx='20'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='%23387CF1'>F</text></svg>" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <nav>
    <a class="brand" href="index.html">FOMC Agent</a>
    <a href="index.html">Home</a>
    <a href="charts.html">Charts</a>
    <a href="pipeline.html">Pipeline</a>
    <a href="architecture.html">Architecture</a>
    <a href="diagrams.html">Diagrams</a>
    <a class="active" href="design.html">Docs</a>
    <a href="about.html">About</a>
  </nav>

  <div class="container">
    <div class="page-header">
      <h1>Architectural Decision Records</h1>
      <p class="subtitle">Key technical decisions made during the design and build of this pipeline, recorded for future reference.</p>
    </div>

    <!-- ADR-001 -->
    <div class="card prose">
      <h2>ADR-001: Use S3 for Static Site Hosting</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-15</td></tr>
      </table>
      <h3>Context</h3>
      <p>The project needs a way to publish pipeline results as a public website. Options include EC2 with Nginx, Amplify, or S3 static website hosting.</p>
      <h3>Decision</h3>
      <p>Use Amazon S3 static website hosting with CDK's <code>BucketDeployment</code> to upload the <code>site/</code> directory on each deploy.</p>
      <h3>Consequences</h3>
      <ul>
        <li>No server to manage — zero operational overhead.</li>
        <li>Cost is effectively zero for low-traffic sites.</li>
        <li>No server-side rendering — all interactivity is client-side JavaScript.</li>
      </ul>
    </div>

    <!-- ADR-002 -->
    <div class="card prose">
      <h2>ADR-002: Plain HTML Over a Static Site Generator</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-15</td></tr>
      </table>
      <h3>Context</h3>
      <p>Static site generators like Hugo or Jekyll add build complexity and toolchain dependencies. This is a workshop project where simplicity and transparency matter more than content-management features.</p>
      <h3>Decision</h3>
      <p>Author all pages as plain HTML and CSS with no build step. Data is loaded at runtime from JSON files generated by the Python analytics pipeline.</p>
      <h3>Consequences</h3>
      <ul>
        <li>No build toolchain required — pages are deployed as-is.</li>
        <li>Navigation must be duplicated across pages (no layout inheritance).</li>
        <li>Students can inspect and understand every line without learning a templating language.</li>
      </ul>
    </div>

    <!-- ADR-003 -->
    <div class="card prose">
      <h2>ADR-003: SQS to Decouple Ingestion from Analytics</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-20</td></tr>
      </table>
      <h3>Context</h3>
      <p>After the data-fetcher Lambda writes raw files to S3, the analytics Lambda needs to run. This could be done synchronously (invoke directly), via S3 event notifications to Lambda, or through an SQS queue.</p>
      <h3>Decision</h3>
      <p>Use S3 event notifications to publish to an SQS queue, which triggers the analytics Lambda. A dead-letter queue captures failed messages.</p>
      <h3>Consequences</h3>
      <ul>
        <li>Ingestion and analytics are fully decoupled — either can fail independently.</li>
        <li>Built-in retry semantics and DLQ for observability.</li>
        <li>Adds an extra AWS resource to manage, but CDK makes this trivial.</li>
      </ul>
    </div>

    <!-- ADR-004 -->
    <div class="card prose">
      <h2>ADR-004: CDK Over CloudFormation or Terraform</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-10</td></tr>
      </table>
      <h3>Context</h3>
      <p>Infrastructure needs to be defined as code. CloudFormation (YAML/JSON), Terraform (HCL), and AWS CDK (Python) are all viable options.</p>
      <h3>Decision</h3>
      <p>Use AWS CDK with Python so that infrastructure code and application code share the same language and can live in the same repository.</p>
      <h3>Consequences</h3>
      <ul>
        <li>One language (Python) for the entire project — lower cognitive overhead.</li>
        <li>CDK constructs provide sensible defaults and higher-level abstractions.</li>
        <li>Requires the CDK CLI and Node.js runtime in addition to Python.</li>
      </ul>
    </div>

    <!-- ADR-005 -->
    <div class="card prose">
      <h2>ADR-005: BLS Flat Files Over API</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-20</td></tr>
      </table>
      <h3>Context</h3>
      <p>BLS provides data through both a REST API and publicly hosted flat files (the LABSTAT database). The API has rate limits and requires registration; flat files are freely available over HTTPS.</p>
      <h3>Decision</h3>
      <p>Ingest directly from BLS LABSTAT flat files, using HTTP <code>Last-Modified</code> headers for change detection to avoid re-downloading unchanged files.</p>
      <h3>Consequences</h3>
      <ul>
        <li>No API key management or rate-limit handling.</li>
        <li>Flat file parsing requires understanding the BLS series ID format.</li>
        <li>Change detection via timestamps is simple and effective for batch ingestion.</li>
      </ul>
    </div>

    <!-- ADR-006 -->
    <div class="card prose">
      <h2>ADR-006: Chart.js for Client-Side Visualization</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-25</td></tr>
      </table>
      <h3>Context</h3>
      <p>The site needs to render time series charts from JSON data. Options include D3.js, Chart.js, and server-side image generation.</p>
      <h3>Decision</h3>
      <p>Use Chart.js loaded from a CDN. A single <code>app.js</code> script renders all charts by reading data attributes from canvas elements.</p>
      <h3>Consequences</h3>
      <ul>
        <li>Simple, declarative API — charts are configured with a few lines of JavaScript.</li>
        <li>Interactive tooltips and responsive sizing out of the box.</li>
        <li>Less customizable than D3, but sufficient for this project's needs.</li>
      </ul>
    </div>

    <!-- ADR-007 -->
    <div class="card prose">
      <h2>ADR-007: Lambda Over Container Deployment</h2>
      <table>
        <tr><th>Status</th><td><span class="badge badge-green">Accepted</span></td></tr>
        <tr><th>Date</th><td>2025-01-20</td></tr>
      </table>
      <h3>Context</h3>
      <p>The project needs compute for data ingestion and analytics processing. Options include ECS/Fargate containers, EC2, or Lambda functions. The <a href="https://github.com/rearc-data/quest" target="_blank" rel="noreferrer">Rearc Quest</a> assignment mentions containerization as a consideration.</p>
      <h3>Decision</h3>
      <p>Use AWS Lambda functions for all compute workloads instead of containerized services.</p>
      <h3>Rationale</h3>
      <ul>
        <li><strong>Scale-to-zero:</strong> Lambda has no idle cost — perfect for infrequent batch jobs that run hourly or daily.</li>
        <li><strong>No long-running processes:</strong> Data fetches and analytics complete well under Lambda's 15-minute timeout.</li>
        <li><strong>Simpler operational model:</strong> No cluster management, scaling policies, or container orchestration required.</li>
        <li><strong>Native AWS integration:</strong> Lambda integrates directly with EventBridge (scheduling), SQS (event-driven triggers), and S3 (notifications).</li>
      </ul>
      <h3>Trade-offs</h3>
      <ul>
        <li><strong>Memory limit:</strong> Lambda's 10GB memory limit is more than sufficient for our small-to-medium datasets.</li>
        <li><strong>Timeout:</strong> The 15-minute maximum is acceptable since data updates complete in seconds.</li>
        <li><strong>Cold starts:</strong> Not a concern for batch workloads that don't require sub-second latency.</li>
      </ul>
      <h3>Consequences</h3>
      <ul>
        <li>Cost efficiency — pay only for actual execution time, not idle containers.</li>
        <li>Reduced infrastructure complexity compared to ECS/Fargate.</li>
        <li>If workloads eventually require longer processing or larger memory, migration to Fargate is straightforward.</li>
      </ul>
    </div>

  </div>

  <script src="lightbox.js"></script>
</body>
</html>
